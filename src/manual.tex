\documentclass{book}

%-------------------------------------------------------------------------------
% Packages
%-------------------------------------------------------------------------------

\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{courier}
\usepackage{mathabx}
\usepackage[os=win]{menukeys}

%-------------------------------------------------------------------------------
% Commands
%-------------------------------------------------------------------------------

\newcommand{\Blockycraft}{Blockycraft}
\newcommand\assets{"../assets"}
\newcommand{\asset}[2]{"\assets/#1".#2}
\newcommand{\screenshot}[4]{
	\begin{figure}[!ht]%	
	\centering%
	\label{#3}%
	\includegraphics[width=#4]{\asset{#1}{png}}%
	\caption{#2}%	
	\end{figure}%
}

%-------------------------------------------------------------------------------
% Document
%-------------------------------------------------------------------------------

\begin{document}

%-------------------------------------------------------------------------------
% Title Page
%-------------------------------------------------------------------------------

\begin{titlepage}
	\centering
	\includegraphics[width=100mm]{\asset{icon}{png}}\\
	\vspace{1.5cm}
	{\huge\bfseries Blockycraft Manual\par}
	{\Large\itshape Jonathan Beverly (\href{jrbeverly.me}{jrbeverly})\par}
	\vfill
	{\large\textbf{Abstract}\par}
	\vspace{1.0cm}
	\Blockycraft{} is a Minecraft inspired demo for illustrating techniques to accomplish graphical objectives.
	\\\vspace{0.5cm}
	{\large \today\par}
\end{titlepage}

%-------------------------------------------------------------------------------
% Contents of Manual
%-------------------------------------------------------------------------------

\tableofcontents
\listoffigures

%-------------------------------------------------------------------------------
% Introduction
%-------------------------------------------------------------------------------

\chapter{Introduction}
\section{Purpose}
\Blockycraft{} is an interactive demo that uses standard first person controls to navigate through a block world. \Blockycraft{} is a Minecraft inspired demo for illustrating techniques to accomplish graphical objectives. The demo revolves around breaking and placing blocks. The game world is composed of rough cubes arranged in a fixed grid pattern and representing different materials, such as dirt, stone, and snow.  The techniques used in the demo can be toggled using keyboard commands.  Included in the project are technical components such as collision, world generation, shadows and lighting.

\section{Overview of Features}
\Blockycraft{} is an interactive demo that bundles together a series of graphics techniques.  The interactive demo includes components such as a primitive user interface, texture mapping, perlin noise, 3-dimensional collision, transparency, keyframe animation, sound, lighting, shadows and ambient occlusion.  The user interface (UI) serves the purpose of facilitating the placement and destruction of blocks in the world.  The scene consists of textured cubes in a procedurally generated 3-dimensional world.  The texturing of the cubes is handled through UV Mapping.  The world is procedurally generated using Improved Perlin Noise and Octave Perlin, to produce both rolling plains and mountainous terrain.  Collision focuses on the player and the blocks that make up the 3-dimensional world.  Blocks in the scene can make use of transparency, to improve aesthetics of the world.  The interactive demo includes particles, sound and keyframe animation.  Finally to ensure that the scene is visually appealing, it includes global lighting, block lighting, shadows and ambient occlusion.  Certain features can be toggled allowing the isolation of other features in the code, or keeping all of them enabled to experience the full \Blockycraft{} environment.

\section{Glossary of Terms}
\begin{itemize}
\item \textbf{Direction of Interaction} - Refers to the view vector of the player.
\item \textbf{Selected Block} - Defines the block intersected with the view vector of the player.
\item \textbf{Chunk} - A spatial partition of the 3-dimensional blocks.
\item \textbf{Fragment} - A collection of values produced by the Rasterizer. Each fragment represents a sample-sized segment of a rasterized Primitive.
\end{itemize}

%-------------------------------------------------------------------------------
% Manual
%-------------------------------------------------------------------------------

\chapter{Manual}
\section{Running the Program}
\subsection{Compilation and Execution}
The program uses the \textbf{premake4} build system to handle the creation of compilation targets.  To build the program, navigate to the top level directory and create the program makefile (\texttt{premake4 gmake \&\& make}).  To build the project, navigate to the source directory (\texttt{src}) and create the program makefile (\texttt{premake4 gmake \&\& make}).
This process is outlined in the \texttt{README} of the source.  To run the program after compiling, simply run `\texttt{./Blockycraft}' from the command line.  To quit the program press \keys{Escape}.

\subsection{Dependencies}
In addition to the premake4 build system, the following libraries are dependencies of this application: 
\begin{itemize}
	\item \href{https://github.com/nigels-com/glew}{GLEW} - The OpenGL Extension Wrangler Library (GLEW) is a cross-platform open-source C/C++ extension loading library.
	\item \href{https://www.opengl.org/resources/libraries/}{GLU} - The OpenGL Utility Library.
	\item \href{http://www.glfw.org/docs/latest/}{GLFW3} - Multi-platform for simple, platform-independent API for creating windows, contexts and surfaces, reading input, handling events.
	\item \href{http://lodev.org/lodepng/}{Lodepng} - LodePNG is a PNG image decoder and encoder.
	\item \href{https://www.libsdl.org/}{SDL} - Simple DirectMedia Layer is a cross-platform development library designed to provide low level access to graphics hardware.
	\item \href{https://www.libsdl.org/projects/SDL_mixer/}{SDL Mixer} - SDL mixer is a sample multi-channel audio mixer library. 
\end{itemize}

\section{Controls}
\subsection{Mouse}
The interactive demo uses the standard mouse and keyboard movements controls for navigating a 3-dimensional world.  Using the mouse, you can change the angle of viewing (or direction of interaction), which is represented by a cross-hair.  The mouse is captured, so in order to regain control of the mouse cursor you will need to exit the program using \keys{Escape}.  You can switch context using \keys{\Alt + Tab \tab} but it does not always return control of the mouse cursor.

\subsection{Keyboard}
The interactive demo uses the standard mouse and keyboard movements controls for navigating a 3-dimensional world.   Using the keyboard, you can navigate through the 3-dimensional world using the \keys{W}, \keys{A}, \keys{S}, \keys{D} keys.  The player will move through the scene, but will be constrained by the blocks of the world.  To fully observe the demo, you can use the \keys{Tab \tab} key to enable you to fly through the scene.

\subsection{Action Keys}
\begin{itemize}
	\item \keys{W} - Moves the player character forward relative to the view direction.
	\item \keys{A} - Moves the player character to the left relative to the view direction.
	\item \keys{S} - Moves the player character backward relative to the view direction.
	\item \keys{D} - Moves the player character to the right relative to the view direction.
	\item \keys{Space} - The player will jump in the scene. (or move vertically if flying is enabled)
	\item \keys{Tab \tab} - Toggles flying, allowing you to fly through the scene.
\end{itemize}
      
\subsection{Special Keys}
\begin{itemize}
	\item \keys{Escape} - Quits the program. 
	\item $\uparrow$ \keys{Z}, $\downarrow$ \keys{X} - Adjusts the visible global light in the scene.
	\item $\uparrow$ \keys{J}, $\downarrow$ \keys{K} - Adjusts the frequency value used in the Octave Perlin Noise.
	\item $\uparrow$ \keys{C}, $\downarrow$ \keys{V} - Adjusts the radius of chunks present in the scene.
	\item \keys{F}, \keys{G} - Cycles between the available block types for placement.
	\item \keys{P} - Toggles the visibility of particles.
	\item \keys{O} - Toggles the orientation component of the Cloud animation.
	\item \keys{L} - Toggles the selected block to become a Light Emitting block.
	\item \keys{M} - Toggles the audio in the interactive demo.
\end{itemize}
      
\subsection{Toggle Function Keys}
The number keys toggle specific features in the scene.
\begin{itemize}
	\item \keys{2} - Toggles the visibility of the user interface.
	\item \keys{3} - Toggles the textures of blocks within the scene.
	\item \keys{4} - Constructs the world based on the current generation preferences (frequency).
	\item \keys{7} - Toggles the transparency of blocks in the scene.
	\item \keys{8} - Toggles the visibility of clouds in the scene.
	\item \keys{9} - Toggles the visibility of particles in the scene.
\end{itemize}

%-------------------------------------------------------------------------------
% Technical Components
%-------------------------------------------------------------------------------

\chapter{Technical Components}
\section{The Scene}
The interactive demo is inspired by Minecraft, a world composed of grid-aligned cubes (known as \textit{Blocks}) in a procedurally generated 3-dimensional world.  You can build constructions using the different types of blocks.  The world is composed of a set of blocks spatially partitioned into chunks.  Each chunk is used to locate objects by storing them in a data structure organized by their positions.   A chunk is a region of \texttt{32 x 32 x 32} (width, height, depth), that stores \texttt{32768} blocks of the scene.
\vskip 2.5mm\noindent
See Appendix \ref{appendix:world} for the voxel world at a glance.
  
\section{User Interface}
The user interface (UI) serves the purpose of facilitating the placement and destruction of blocks in the world.  As the 3-dimensional world consists of different types of blocks, a selection pane is present that shows the current block type for placement.  The angle of viewing (or direction of interaction) is represented by the cross-hair, a small cross in the middle of the screen.  It shows the exact point where you will use actions such as block placement or destruction.
\vskip 2.5mm\noindent
The user interface can be toggled by the key \keys{2}.  The block type can be cycled using the keys \keys{F} and \keys{G}.

\section{UV Texture Mapping}
The interactive demo consists of textured cubes in a procedurally generated 3-dimensional world.  The texturing of the cubes is handled through UV Mapping.  All blocks textures are defined in a sprite sheet that contains the blocks textures stored as several smaller graphics in a tiled grid arrangement.  The spritesheet uses a single value to index each tile in the grid arrangement.  The value is computed by determining the current ($x$, $y$) position the cube texture, then creating a ratio from the total size of the spritesheet.
\vskip 2.5mm\noindent
The texturing of the blocks can be toggled by the key \keys{3}.  See Appendix \ref{appendix:shadows} and \ref{appendix:occlusion} for the world with texture mapping toggled.

\section{Perlin Noise}
The procedurally generated world in the interactive demo is generated through Improved Perlin Noise combined with Octave Perlin Noise.  The implementation of Improved Perlin Noise is a faithful interpretation of the java reference implementation provided in the SIGGRAPH Paper by Ken Perlin.  Slight modifications have been made to the implementation for C++, however the code remains faithful to the reference implementation.

The bulk of the Improved Perlin Noise implementation is with the method \texttt{noise}.  The method handles the construction of a unit cube for the purposes of calculating gradient vectors to compute the noise value.  The implementation of the \texttt{fade} function is important to understanding the sloping nature of the generated world.  The \texttt{fade} function implements an ease curve in order to provide a smooth transition between vector gradients.  This is because linear interpolation tends to produce an unnatural effect. The final result produced by the algorithm can remain relatively flat or similar to rolling planes.  Ideally we wish to be able to provide a wider breadth of world types, specifically more mountainous terrain.  Octave Perlin was implemented to produce more mountainous terrain as necessary.  The introduction of Octave Perlin added an amplitude and frequency, where the frequency determines how squished together the result is, while the amplitude determine the potential heights of peaks.
    
For the \Blockycraft{} demo the amplitude is set at the height of a chunk which is currently \texttt{32}.  The frequency is variable based on user input, but to produce reasonable results it is within the range of [\texttt{0.01}, \texttt{0.1}].  The initialized value for the frequency is \texttt{0.01}, which produces rolling plains as visible in Appendix \ref{appendix:perlin}.  Higher values such as \texttt{0.06} will produce more mountainous terrain which can also be seen in Appendix \ref{appendix:perlin}.  At sufficiently large values the world will produce an almost city-like landscape.
\vskip 2.5mm\noindent
The procedurally generated world can be regenerated using the key \keys{4}.  See Appendix \ref{appendix:perlin} for visual examples of world generation based on Perlin Noise the varying frequency inputs.
    
\section{Static Collision}
Static collision in the demo is concerned with the player and the blocks of the procedurally generated world.  This method of collision works by focusing on the current and future positions of the player.  As the collision in the demo is limited to just the player, the movement of the player and collision are closely tied together.  The player position is adjusted when the player collides with a block, adjusting to the colliding block and a padding component to ensure consistency.

To ensure that no visual conflicts occur, all collision code includes a padding component.  The padding extends the collision boundaries of blocks in the scene by a small amount.   The amount is significant enough to ensure no visual discrepancies occur from close proximity to the blocks, as well as ensuring that the player collision remains smooth.  The padding component discussed above can be experienced by running towards the edges of a block.  If you collide in just the right position, the player will be adjusted to the block neighbour, allowing you to skirt past the block.
   
\section{Transparency}
Transparency in the technical demo uses a \texttt{transparency colour}, which are pixels set to a value that is ignored in the graphics pipeline.  A sprite sheet that contains the blocks textures stored as several smaller graphics in a tiled grid arrangement, any transparent pixel is set to a pixel value of magenta (\texttt{RGB - 1.0, 0.0, 1.0}).  When the texture is passed to an OpenGL Shader, it checks to see if the fragment should be drawn with respect to the transparency colour.  When transparency is disabled, the magenta colour is visible as seen in Appendix \ref{appendix:transparency}.
\vskip 2.5mm\noindent
The transparency can be toggled by the key \keys{7}.  Appendix \ref{appendix:transparency} presents a comparison of the transparency pixel.
    
\section{Keyframe Animation}
The interactive demo includes clouds floating above the scene.  Each of the clouds has a set of keyframes with positional and orientation values.  Using linear interpolation, the position and orientation of a cloud at a given moment can be computed.  The timing component of the clouds is incremented by a speed factor with respect to the passage of time between frames.  This ensures that the movement of clouds is bound to time as opposed to number of frames.  The cloud is drawn at the linearly interpolated position.
\vskip 2.5mm\noindent
The visibility of clouds can be toggled by the key \keys{8}.  The orientation component of the clouds can be toggled with the key \keys{O}.  See Appendix \ref{appendix:clouds} for example of the clouds in the scene.

\section{Particle System}
The interactive demo includes dust particles that appear after the destruction of a block.  When the block is destroyed, a set of dust particles appear for a short duration, moving randomly away from the center of the destroyed block in a random direction.  The dust particles are scaled based on a factor of time, disappearing after a short period.  The movement code requires that the particles will always move away from the center of the destroyed cube.  To ensure that the particles remain visually consistent, they are using a billboard effect.  The billboard effect used with the particles requires the removal of the rotational component of the world-view matrix.  To do this the inner \texttt{3x3} matrix is set to the identity matrix, then the scalar component is reapplied.  The final result is a dust particle that always faces towards the player.
\vskip 2.5mm\noindent
The visibility of particles can be toggled by the key \keys{9}.  The visual state of particles can be toggled by the key \keys{P}.  See Appendix \ref{appendix:particles} for a visual representation of dust particles in varying visual states.

\section{Sound}
The interactive demo includes a sound component, that plays both ambient audio and world music.  As the player traverses through the scene, they will hear audio based on the current terrain.  The footsteps audio is pseudo-randomly chosen in order to prevent the footstep sounds from being repetitive.  Using similar code as the collision detection, the footstep audio changes according to the terrain.  For ambience, the scene has audio playing in the background based on where the player is currently.  Whether the player is roaming above ground or splunking, the background audio will change accordingly.  This is done using similar code as the collision detection, to verify if the player is currently underground.
\vskip 2.5mm\noindent
The audio in the demo can be disabled using the key \keys{M}.
    
\section{World Lighting}
The interactive demo has static lighting that represents the lighting of the world.  The lighting value is known as time of day and provides an overall lighting factor for the scene.  To ensure that the world lighting does not oversaturate the scene, the potential contribution value is capped within the range of \texttt{[0.2, 0.5]}.  The lighting value for any fragment in the scene is a composite of diffuse, ambient occlusion, daylight lighting values, and any incident light from light emitting objects present in the scene.
\vskip 2.5mm\noindent
The world lighting can be adjusted with the keys \keys{X} and \keys{Z}.
    
\section{Light Emitting Cube}
Blocks in the world can be enabled as a light emitting block.  Any block can be set as a light emitting block, which will emit light influencing the lighting values of neighbouring blocks.  Light is distributed throughout the scene in a radial manner from the cube, dissipating based on distance.  The result is a diamond-like light formation emitting from the cube, which can be seen in Appendix \ref{appendix:light}.  When preparing the chunk for drawing, the lighting for each cube is factored into the graphics buffer for a spatial chunk.  The texture mapping, shadows and ambient occlusion are also addressed in this stage.  
\vskip 2.5mm\noindent
A cube in the world can be toggled as a light emitting cube using the key \keys{L}.  See Appendix \ref{appendix:light} for a visual representation of the light emittance formation.
    
\section{Shadows and Ambient Occlusion}
Shadows are present as height based shadow and ambient occlusion.  Shadows are addressed after the lighting pass occurs in the scene.  With lighting addressed, the shading component must be evaluated based on the neighbouring cubes.  The considered area with a \texttt{3x3x3} region around the current block.  In total \texttt{27} are in the region, with \texttt{26} blocks needing to be considered.  The height shading component is evaluated by iterating vertically and determining shading based on the height.  The shadows present on blocks is visible in Appendix \ref{appendix:shadows} and \ref{appendix:occlusion}.

In Block-based worlds, the calculation for ambient occlusion is significantly easier as the shading influence on the environment is fairly straightforward.  The contribution nearby blocks have to the currently vertex based on positions.  In this world we have to consider when blocks are present on the sides of a vertex, and when a corner block is present.  A set of block configurations for a block vertex is visible in Appendix \ref{appendix:occlusion}.  These three blocks greatly influence the ambient occlusion value for the vertex.

%-------------------------------------------------------------------------------
% Conclusion
%-------------------------------------------------------------------------------

\chapter{Conclusion}
\section{Initial Iteration}
The initial iteration of \Blockycraft{} had some major flaws in its design due to time constraints and misconceptions that existed during development of the project.  The project architecture did not readily facilitate unit or even smoke testing of key algorithms of the project.  An example is the storage of 3 dimensional data, which used a standard array with poor bounds checking and space management.  Under certain conditions this structure could cause segmentation faults.   

The project did not make use of parallelization, as the original code architecture did not lend itself to multi-threaded environments.  The method to generate chunks, a 3 dimensional spatial region, could not easily be parallelized in the initial implementation.  As such spatial chunks needed to be generated linearly, which resulted in a significant delay in application startup and world generation.

The initial iteration was written to be functional, as opposed to expressive.  Improvements in the \Blockycraft{} source code focus on ensuring the code was structured in a testable manner.  By separating the graphics components from the algorithms, this enabled the code to be parallelized and properly validated.

\section{Acknowledgements}
I would like to acknowledge a collection of blog posts and resources by block-world enthusiasts who provided the basis for the project.

\begin{enumerate}
	\item Kenny Voxel Pack. {\em \href{http://kenney.nl/assets/voxel-pack}{Voxel Pack.}} \texttt{(\url{http://kenney.nl/})}
	\item BÃ¶sch, F. 2010. {\em \href{http://codeflow.org/entries/2010/dec/09/minecraft-like-rendering-experiments-in-opengl-4/#ambient-occlusion}{Minecraft Like Rendering Experiments in OpenGL 4.}} \texttt{(\url{http://codeflow.org/})}
	\item Let's Code. 2011. {\em \href{http://www.sea-of-memes.com/LetsCode35/LetsCode35.html}{Part 35: Minecraft Lighting.}} \texttt{(\url{http://www.sea-of-memes.com/})}
	\item 0FPS. 2013. {\em \href{https://0fps.net/2013/07/03/ambient-occlusion-for-minecraft-like-worlds/}{Ambient occlusion for Minecraft-like worlds.}} \texttt{(\url{https://0fps.net/})}
	\item Seed of Andromeda. {\em \href{https://www.seedofandromeda.com/blogs/29-fast-flood-fill-lighting-in-a-blocky-voxel-game-pt-1/}{Fast Flood Fill Lighting in a Blocky Voxel Game: Pt 1.}} \texttt{(\url{https://www.seedofandromeda.com})}
	\item ByteBash. 2012. {\em \href{http://bytebash.com/2012/03/opengl-volume-rendering/}{OpenGL Minecraft Style Volume Rendering.}} \texttt{(\url{http://bytebash.com})}
\end{enumerate}

%-------------------------------------------------------------------------------
% References
%-------------------------------------------------------------------------------

\nocite{*}
\begin{thebibliography}{1}
	    
	\bibitem{inoise} Perlin, K. 2002. {\em Improving Noise.} Computer Graphics 35(3).
	\bibitem{gpugems}  Perlin, K. 2004. {\em Implementing Improved Perlin Noise.} GPU Gems
	\bibitem{nparticle}  E. Hastings, R. Guha, and K. O. Stanley,. {\em Neat particles: Design, representation, and animation of particle system effects,} Proceedings of the IEEE Symposium on Computational Intelligence and Games (CIG), 2007
	\bibitem{occl} P. Shanmugam, O. Arikan. {\em Hardware accelerated ambient occlusion techniques on GPUs. }  SIGGRAPH 2007.
	\bibitem{voxel}  Wilder, Michael W., {\em An Investigation in Implementing a C++ Voxel Game Engine with Destructible Terrain } (2015). Honors Research Projects. Paper 217.
	\bibitem{bloxel} E. Arneback, A. Lunden, et al {\em Bloxel - Developing a voxel game engine in Java using OpenGL. } GUPEA 2015.
\end{thebibliography}
\bibliographystyle{plain}
\clearpage

%-------------------------------------------------------------------------------
% Appendix
%-------------------------------------------------------------------------------

\appendix
\section*{Appendices}
\addcontentsline{toc}{section}{Appendices}
\renewcommand{\thesubsection}{\Alph{subsection}}

\subsection{World} \label{appendix:world}
\screenshot{world}{The \Blockycraft{} World.}{world}{1.0\textwidth}
\clearpage

\subsection{Perlin} \label{appendix:perlin}
\screenshot{hills}{A generated block world with height corresponding to block type.}{hills}{0.45\textwidth}
\screenshot{plains}{A generated block world with height corresponding to block type.}{plains}{0.45\textwidth}
\screenshot{aerial}{An aerial view of a generated block world.}{aerial}{0.45\textwidth}
\screenshot{high_frequency}{A generated block world with a high frequency value.}{high_frequency}{0.45\textwidth}
\screenshot{medium_frequency}{A generated block world with a reasonable frequency value.}{medium_frequency}{0.45\textwidth}
\screenshot{low_frequency}{A generated block world with a low frequency value.}{low_frequency}{0.45\textwidth}
\clearpage

\subsection{Transparency} \label{appendix:transparency}
\screenshot{transparency}{Transparency toggle on transparency enabled blocks.}{transparency}{1.0\textwidth}
\clearpage

\subsection{Clouds} \label{appendix:clouds}
\screenshot{clouds}{Clouds moving in the environment.}{clouds}{1.0\textwidth}
\clearpage

\subsection{Particles} \label{appendix:particles}
\screenshot{particles}{Particles created after destruction of a block.}{particles}{0.55\textwidth}
\screenshot{billboard}{The billboarding of the particles.}{billboard}{0.55\textwidth}
\clearpage

\subsection{Light Emitting} \label{appendix:light}
\screenshot{lighting}{Light emitting from a cube.}{lighting}{0.65\textwidth}
\screenshot{light_diamond}{Light pattern from a cube.}{emitting}{0.65\textwidth}
\clearpage

\subsection{Height Shadows} \label{appendix:shadows}
\screenshot{shadows}{Ground shadows based on the positioning of cubes.}{shadows}{0.65\textwidth}
\screenshot{shadows_height}{Ground shadows based on the height of cubes.}{heightshadows}{0.65\textwidth}
\clearpage

\subsection{Ambient Occlusion} \label{appendix:occlusion}
\screenshot{aocclusion_angle}{Angled view of ambient occlusion based on neighbouring block configurations.}{occlusion}{0.65\textwidth}
\screenshot{aocclusion}{Ambient occlusion based on neighbouring block configurations.}{aocclusion}{0.65\textwidth}

\end{document}
