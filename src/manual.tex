\documentclass{book}

%-------------------------------------------------------------------------------
% Packages
%-------------------------------------------------------------------------------
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{courier}
\usepackage[os=win]{menukeys}

%-------------------------------------------------------------------------------
% Commands
%-------------------------------------------------------------------------------

\newcommand{\Blockycraft}{\textbf{Blockycraft}}
\newcommand\assets{"../assets"}
\newcommand{\asset}[2]{"\assets/#1".#2}
\newcommand{\screenshot}[4]{
	\begin{figure}[!ht]%	
	\centering%
	\includegraphics[width=#4]{\asset{#1}{png}}%
	\caption{#2}%
	\label{#3}%
	\end{figure}%
}

%-------------------------------------------------------------------------------
% Document
%-------------------------------------------------------------------------------

\begin{document}

%-------------------------------------------------------------------------------
% Title Page
%-------------------------------------------------------------------------------

\begin{titlepage}
	\centering
	\includegraphics[width=50mm]{\asset{icon}{png}}\\
	\vspace{1.5cm}
	{\huge\bfseries Blockycraft Manual\par}
	{\Large\itshape Jonathan Beverly (\href{jrbeverly.me}{jrbeverly})\par}
	\vfill
	{\large\textbf{Abstract}\par}
	\vspace{1.0cm}
	\Blockycraft{} is a Minecraft inspired demo for illustrating techniques to accomplish graphical objectives.
	\\\vspace{0.5cm}
	{\large \today\par}
\end{titlepage}

\tableofcontents

%-------------------------------------------------------------------------------
% Introduction
%-------------------------------------------------------------------------------

\chapter{Introduction}
\section{Purpose}
\Blockycraft{} is a Minecraft inspired demo for illustrating techniques to accomplish graphical objectives.  It is a interactive demo that allows the user to navigate through the environment using keyboard and mouse commands.  The techniques used in the demo can be toggled using keyboard commands.  Included in the project are technical components such as collision, world generation, shadows and lighting.
\\\\
The \Blockycraft{} project was a positive experience in learning and applying graphics oriented techniques.  Applying Perlin Noise to the environment to produce varying environments, then seeing it come together with lighting and shadows produces an engaging world.

\section{Overview of Features}
The interactive demo is navigated using first-person controls, similar to first-person shooter games.
A user interface allows the user to see the currently block status.  Texture mapping allow for the blocks in the world to be of varying types.  The world is generated using Improved Perlin Noise in order to keep the world dynamic.  Octave Perlin is used to control the presence of rolling hills or high altitude mountains.  Static collision is creating by detecting collision of the player with the scene, and is fairly straightforward.  Dynamic collision was not completed, but it was intended that objects would exist in the scene that the player could collide with causing an effect similar to a knockback.  

Transparency exists in the block objects to enable the glass and leaves block types.  It uses a specific colour (magenta) to identify components that are transparent.  Keyframe animation exists within the clouds in order to move them in an interesting manner.  Each of the clouds has their own unique set of keyframes to keep the cloud movement interesting.  Sound was added using SDL Mixer - sound effects are synchronized with movement in the game.  Specifically the type of block the player is currently walking on determine the footstep noise.  If the player is above blocks the 'overworld' song will play, if underground it will play a different song. Additional light and shading factors were added into the final result in order to improve the visual aspect of the interactive demo.  These features can all be enabled at once to provide the full Minecraft experience. Most of them can be toggled by pressing a number key associated with the objective. 

\section{Glossary of Terms}
\begin{itemize}
\item \textbf{Direction of Interaction} - Defines the vector direction of the player view.
\item \textbf{Selected Block} - Defines the block intersected with the vector direction of the player.
\end{itemize}

%-------------------------------------------------------------------------------
% Manual
%-------------------------------------------------------------------------------

\chapter{Manual}
\section{Running the Program}
\subsection{Compilation and Execution}
The program uses the \textbf{premake4} build system to handle the creation of compilation targets.  To build the program, navigate to the top level directory and create the program makefile (\texttt{premake4 gmake  make}).  To build the project navigate to the source directory (\texttt{src}) and create the program makefile (\texttt{premake4 gmake make}).
This process is outlined in the \texttt{README} of the source.

To run the program after compiling, simply run `\texttt{./Blockycraft}' from the command line.  To quit the program press \keys{Escape}.


\subsection{Dependencies}
In addition to the premake4 build system, the following libraries are dependencies of this application: 
\begin{itemize}
	\item \href{https://github.com/nigels-com/glew}{GLEW} - The OpenGL Extension Wrangler Library (GLEW) is a cross-platform open-source C/C++ extension loading library.
	\item \href{https://www.opengl.org/resources/libraries/}{GLU} - The OpenGL Utility Library
	\item \href{http://www.glfw.org/docs/latest/}{GLFW3} - Multi-platform for simple, platform-independent API for creating windows, contexts and surfaces, reading input, handling events.
	\item \href{http://lodev.org/lodepng/}{Lodepng} - LodePNG is a PNG image decoder and encoder.
	\item \href{https://www.libsdl.org/}{SDL} - Simple DirectMedia Layer is a cross-platform development library designed to provide low level access to graphics hardware.
	\item \href{https://www.libsdl.org/projects/SDL_mixer/}{SDL Mixer} - SDL mixer is a sample multi-channel audio mixer library. 
\end{itemize}

\section{Controls}
\subsection{Mouse}
The interactive demo uses the standard mouse and keyboard movements controls for navigating a 3-dimensional world.  Using the mouse, you can change the angle of viewing, as well as the direction of interaction.  The mouse is captured, so in order to regain control of the mouse cursor you will need to exit the program using \keys{Escape} or switch context using \keys{\Alt + Tab \tab}.

\subsection{Keyboard}
The interactive demo uses the standard mouse and keyboard movements controls for navigating a 3-dimensional world.   Using the keyboard, you can navigate through the 3-dimensional world using the \keys{W}, \keys{A}, \keys{S}, \keys{D} keys.  The player position will move through the scene, but will be constrained to the world.  To fully observe the demo, you can use the \keys{ Tab \tab} key to enable you to fly through the scene. 

\subsection{Action Keys}
\begin{itemize}
	\item \keys{W} - Moves the player character forward relative to the view direction.
	\item \keys{A} - Moves the player character to the left relative to the view direction.
	\item \keys{S} - Moves the player character backward relative to the view direction.
	\item \keys{D} - Moves the player character to the right relative to the view direction.
	\item \keys{Space} - The player will jump in the scene (or move vertically if flying is enabled)
	\item \keys{ Tab \tab} - Toggles flying, allowing you to fly through the scene.
\end{itemize}
      
\subsection{Special Keys}
\begin{itemize}
	\item \keys{Escape} - Quits the program. 
	\item \keys{Z}/\keys{X} - Increases/Decreases the amount of visible global light.
	\item \keys{J}/\keys{K} - Increases/Decreases the frequency value used in the Octave Perlin Noise.
	\item \keys{C}/\keys{V} - Increases/Decreases the radius of chunks present in the scene.
	\item \keys{F}/\keys{G} - Cycles between the available block types for placement.
	\item \keys{P} - Toggles the visibility of particles.
	\item \keys{O} - Toggles the orientation component of the Cloud animation.
	\item \keys{L} - Toggles the selected block to become a Light Emitting block.
\end{itemize}
      
\subsection{Toggle Settings Keys}
The number keys toggle specific features in the scene.
      
\begin{itemize}
	\item \keys{2} - Toggles the visibility of the user interface.
	\item \keys{3} - Toggles the UV Mapping of objects within the scene.
	\item \keys{4} - Regenerates the world and resets the current scene properties.
	\item \keys{7} - Toggles the application of transparency.
	\item \keys{8} - Toggles the visibility of clouds in the scene.
	\item \keys{9} - Toggles the visibility of particles in the scene.
\end{itemize}

%-------------------------------------------------------------------------------
% Technical Components
%-------------------------------------------------------------------------------

\chapter{Technical Components}
\section{The Scene}
The scene is composed of a set of Blocks that are collected into a set of Chunks.  Each Chunk acts as a 32x32x32 region that stores 32768 blocks of the scene.  This spatial separate is for the purposes of making rendering of the scene easier. 
  
See also Appendix A for a visual of the voxel world.
  
\section{User Interface}
The user interface is defined by two components.  The first component is a cross-hair that represents the current sight vector of the player.  The second component is a block is the bottom-left corner of the screen representing the currently selected block.  The selected block is the type of block that will be placed when perform the mouse right click interaction.
    
The first component involves making us of the player rotational coordinates (x, y) that determine the current sight of the player.  These two values are used to calculate the sight vector that is used to determine the block the player is currently interacting with through mouse interaction.
    
The second component can be altered by the keys F and G.  These allow the type to be changed, allowing different kinds of blocks to be placed in the scene.
    
The user interface can be enabled and disable using the number key 2. 
    
\section{UV Texture Mapping}
All blocks in the scene are textured using UV Mapping.  All the block textures are currently defined in a spritesheet called Textures.  This asset was acquired from the `Minecraftforum.net`
submitted by the user CaptainJoe102 under the resource name 'Minecraft PE Original Texture Pack'.
    
When a cube is created using the 'construct-cube' function (see cube.cpp), the UV values of the cube are set.  This value is computed by determining the current (x, y) position the cube texture face is in the spritesheet.  Using this the exact UV ratio position is computed by factoring in the total size of the spritesheet (2048) with respect to the size of each of the texture blocks (16 pixels).  This is how the UV coordinate of a texture is computed with respect to the spritesheet.
    
The texture block indices are provided by a BlockDefinition structure (see block.h) that defines the index in the spritesheet of the specified face.  These indices are defined by the method getBlockDefinitions (see block.h) that quickly constructs the mapping of block type with the positions within the spritesheet.
    
See also Appendix G and H for the visual representation of the world without UV Mapping.
    
\section{Perlin Noise}
The world in the interactive demo is generated through Improved Perlin Noise combined with Octave Perlin Noise.  The implementation of Improved Perlin Noise (see pnoise.h) is a faithful interpretation of the java reference implementation provided in the SIGGRAPH 2002 Paper by Ken Perlin.  Although some slight modifications have been made, the code is faithful to his reference implementation.
    
In my implementation, during each initialization of the PerlinNoise structure, it reinitializes the permutation vector (p) in order to keep the world changing between each world reset.  The world can be regeneration with the number key 4.
    
For the implementation of Perlin Noise, the algorithmic work is done by the 'noise(double x, double y, double z)' method.  In this method five key steps are performed:
    
\begin{itemize}
	\item Construction of the Unit Cube.
	\item Relative X, Y, Z within the Unit Cube.
	\item Determining 8 cube corners for gradient vectors.
	\item Calculation of pseudo-random gradient vectors.
	\item Blending results from the gradient vectors.
\end{itemize}
  
Following through with the process, we first divide the coordinate into unit cubes to find the coordinates location within the cube.
    
On each of the 8 unit coordinates we generate a pseudo-random gradient vector.  In Ken Perlin's \textit{Improved Noise}, the gradient vectors are not completely random, these are actually picked from the point in the center of the cube to the edges of the cube.  This results in a total of 12 potential vectors.
    
For each of the gradient vectors we take the dot product between a gradient vector and the distance vector provided by the input coordinates.  With these final values, we linearly interpolate between the 8 values to get a weighted average between the 8 grid coordinates.  
    
Two points of interest in this code is the `fade` and `grad` functions.  The fade function implements a 'ease curve' in order to provide a smoother transition between gradients.  This is because linear interpolation tends to produce an unnatural effect.
    
The grad function handles the process of calculating the dot product of a randomly selected gradient vector and the 8 location vectors discussed above.  This is done by Ken Perlin using bitwise operations, but the code can be redesign to be less obtuse.
    
On a final note, the final result produced by the algorithm can remain relatively flat or similar to rolling planes.  More ideally we wish to be able to provide a wider breadth of world types (mountains).  To do this Octave Perlin was implemented where an amplitude and frequency were added.  The frequency determines how 'squished' together the result is, while the amplitude determine the heights of peaks.
    
For the implemented code the amplitude is at a constant of 32 (the height of a chunk), while the frequency is variable based on user input.  The initial low value (0.01) produces a rolling plains, while higher values (0.06) will produce more mountainous terrain.  At sufficiently large values the world will produce an almost city-like landscape.
    
See also Appendix B for visual examples of the Perlin Noise results.
    
\section{Static Collision}
    
The collision of the player with blocks in the scene is primairly handled by a single method (see main.cpp).  The method is player-collide and works by first determining where the player is in the world.  With this information a relative position within the current block coordinate can be determined.  
    
From here, we will compute based on the current position if the player is currently colliding with any of the blocks surrounding the current block coordinate.  This means we check collision in all 6 cube directions, as well as upwards based on the height of the player (constant of 2).
    
If no collision occurs, then the player position is not altered.  If a collision does occur then the player position is adjusted to be equal to the block center position with an adjusted padding.  This padding is vital to ensuring that the player does not collide to closely with blocks in the scene.
    
The padding component discussed above can be visually scene by running towards the right or left edge of a block.  If you hit in just the right position, the player will be adjusted to the block neighbour, allowing you to move past the block.
    
\section{Dynamic Collision}
    
Dynamic collision was not finished due to poor time management with respect to the graphics components.  However, this was the current thinking with respect to its implementation.
    
Within the scene would be objects such as a sphere that would move about the scene.  These objects would move about the (x, z) plane randomly based on any positioning algorithm.  The y position would be determined based on an average height of the neighbouring blocks (9 blocks).  In other words, the object would always try to remain higher in the y-coordinate than any nearby blocks in order to avoid collision.
    
When computing collision with the player, a check would be performed to determine if the player and object were within the same spatial chunk.  If they were, a simple bounding sphere calculation would be used to determine collision.  In the event of collision between the object and block, the objects y position would increment rapidly, causing it to fly into the sky much like a power-jump.  
    
\section{Transparency}
    
Within the spritesheet any transparent pixel is set to magenta (RGB - 1.0, 0.0, 1.0).  This was done so that within the shader it could compare the sampled pixel value based on the UV Mapping with the constant value of the magenta.  If this comparison was true, then the shader could discard the pixel knowing that it would be a transparent pixel.
    
The transparency can be toggled by the number key 7.  See also Appendix C for a visual display of transparency.
    
\section{Keyframe Animation}
    
Within the scene are a collection of flat white rectangle clouds.  Each of these clouds in initialized when the scene starts with a set of positional and orientation keyframes.  Using linear interpolation, the position of a cloud at a given moment can be computed.
    
After initializating in \textit{uploadCloudDataToVbos} each of the clouds with their keyframes, they are rendered by \textit{render-clouds}.  The necessary linear interpolation is computed for each cloud, determining the current and next keyframes.
    
The timing component of the clouds is incremented by a speed factor with respect to the passage of time between frames.  This ensures that the movement of clouds is bound to time as opposed to number of frames.  
    
The cloud coordinate (x, y, z) is linearly interpolated to determine where to draw the cloud, as well as the orientation factor of the cloud.  These are provided to the world transformation matrix for positioning of the cloud.
    
The visibility of clouds can be toggled by the number key 8.  The orientation component of clouds can be toggled by the key `O`.  See also Appendix D for a visual representation of the clouds.
    
\section{Particle System}
    
The particle system works by first allocating the graphics buffer for the 'dust' particles (through \textit{uploadDustDataToVbos} in main.cpp).  Once the buffer is allocated, we can render the particles in the system in the method \textit{render-particles}.
    
In the method \textit{render-particles} we iterate through all the particles in the scene to first determine if any have expired.  If they have, they are removed from the list of particles.
    
Remaining particles are computed by determine the position in the world.  The particles are scaled and also move in a random direction based on a factor of time.  This ensures that the particles are moving away from the center of the generated cube.  An important method is `\textit{billboard}`.  For the billboard effect to take place with the particles, we need to remove a rotational component of the world-view matrix.  In this case we are considering a 4x4 matrix, where the bottom row follows the identity matrix, and the right column contains the translation vector.  The 3x3 matrix within the 4x4 matrix handles the rotational component.  If we set this value to the identity matrix, we will remove the rotational component.  However, we wish to preserve the first columns properties, so we compute the $x^2 + y^2 + z^2$ of the first vector.  Using this scalar factor we multiply it against the 3x3 identity matrix, to factor scaling into our final result.
    
When the key `P` is toggled, it switches the particles to a single large block that has a longer expiration period.  This is in order to show that the particle works using billboarding techniques, as this is not clearly visibile when working with particles in their normal form.
    
The visibility of particles can be toggled by the number key 9.  The visual state of particles can be toggled by the key `P`.  See also Appendix E for a visual representation of the visual states of particles.
    
\section{World Sound}
    
An important objective of the interactive demo was to provide realistic sound based on the current position of the player.  This comprised of two components.  The first involved the presence of an overworld and underworld song based on whether the player was above or below a block.   The second component involved determining the current block that the player was moving over, to play specialized footstep sounds.
    
This objective was possible with the `hit-test` method.  By firing a hit ray directly down we are able to detect the type of block the player is currently over.  If movement conditions are met, then we can play the footstep sound.  This is based on a pseudo-random index to determine the footstep variant to use.
    
The `hit-test` method also enables firing a hit ray directly up, in order to detect whether the player is considered 'underground'.  If the player is underground, then we can instruct certain music to play.  Otherwise we default to the overworld music.
    
The `hit-test` method works by determining where the player currently is in the world, as well as the hit ray direction vector.  From this, the code iterates through nearby chunks, as well as the current, if within reasonable distance range as the ray can intersect with cubes in other spatial chunks.
    
The hit-check works similar to that of player-collide, in that we round the position to the nearest logical block determining if the type is collidable.  If not, we continue to shift the ray forward based on the direction vector for each logical block segment (length of a block).
    
The footstep sounds were provided by the software resource 'Minecraft Sounds - Footsteps' by a user called Daenth from the online forum 'blockland'.
    
The footstep audio cannot be disabled at present.
    
\section{World Lighting}
The world was given a static lighting component that factored into the world.  This lighting value is known as 'time of day', and provides the overall lighting factor of the scene.  In this method the value of total lighting factors in the composite of light.
    
It is important that the world light is not too bright or too dark, as such the potential contribution value is capped within the range of [0.2, 0.5] for the light values.  This value is then factored in with respect to the diffuse colour, in order to produce the final colour output.
    
The final lighting value of the scene is a composite of diffuse, ambient occlusion and daylight with the fragment light from light emitting objects factored in for each step. 
    
All computation with respect to world lighting is performed in the `\textit{block.fs}` fragment shader.  
    
The world lighting value can be incremented/decremented by the keys Z and X.
    
\section{Light Emitting Cube}
The light emitting component of the world makes use of a light-map for storing the light contribution of an individual cube.  This can be seen with `light-maps` and `lights` variables in a ChunkGenParams and Chunk (see world.h).  These variables are used to store lighting factors about the world.
    
The key code to distribute the light is handled by `light-fill` in main.cpp.  In this code, it handles the process of distributing the light throughout the scene by spreading out in the 6 cube directions.  This creates a diamond-like light emitting cube, but follows with the Minecraft style of lighting.
    
The `light-fill` method is part of an important piece of code called `\textbf{compute-chunk}`.  This method performs a bulk of creating the graphic buffer for drawing a spatial chunk.  As it handles the setting of light, texture mapping, shaders and ambient occlusion.  The specifics of this method will be covered in more detail later.
    
A cube in the world can be toggled as a light emitting cube using the key L. See also Appendix F for a visual representation of Light emission.
    
An excellent resource for understanding light fill algorithm more is Seed of Andromeda.  See the acknowledgements for this resource. 
    
\section{Shadows and Ambient Occlusion}
    
The bulk of shadow and ambient occlusion code is handled in the method `\textbf{compute-chunk}`. This method makes use of the `\textbf{occlusion}` method found in occlusion.h.  
    
Specifically when creating the graphics buffer for a chunk, we have to follow a process of computing variables for each step.  For better understanding of the following, the Appendices G and H will provide a visual help to understanding shadows and occlusion in the environment.
    
\begin{itemize}
	\item Determine if the scene has any lighting
	\item Determine the opaqueness of blocks (what is visible?)
	\item If a light exists, compute the light strength in the scene
	\item Determine visibility of each face of a block in the scene
	\item Compute the ambient occlusion based on light and shading
	\item Construct the cube from the compiled entries
\end{itemize}
    
The initial steps are fairly straightfoward.  First we iterate through the chunks to see if any have any light data within them.  If they do not, we have no lights.  Next we iterate through all the blocks in the scene, determining which are opaque so that they will be draw.
    
The next steps involved propagating light throughout the scene as defined in `Light Emitting Cube`. Essentially we iterate through all the entries in the cube, and if necessary propagate light from a light emitting position.
    
As we are constructing the buffer based on vertices in the scene, we first need to determine which sides of the block are visible based on the neighbouring blocks.  Once this is known, we can then begin to compute the shading and lighting factors as they influence the visible primitives.
    
In the case of lighting, for each cube we need to consider all 3D neighbours with a distance of 1.  This means we need to consider a 3 by 3 by 3 cube around the current block (27 cubes total including self).  The shading component here is interesting as for each of the surrounding neighbours, we determine the shading factor cast on it by blocks above it.  This is done by iterating up a certain height (y-coordinate) and if any block is visible (opaque), we factor in a shading value based on the height.
    
With these variables we then compute a occlusion factor.  In Minecraft-like worlds, the calculation for occlusion is significantly easier as the effect that the environment can have on the blocks is more limited in terms of number of rays.  Specifically, we only need to consider what kind of contribution nearby blocks have to the currently vertex based on positions.  In this world we have to consider when blocks are present on the sides of a vertex, and when a corner block is present.  These three blocks greatly influence the ambient occlusion value for the vertex.
    
In the method `occlusion` you can see this process of performing a lookup to find neighbour positions based on the face and vertex we are currently working with.  The lookup tables (\textit{neighbour-lookup-table}) work by indexing the cube face (cell) and vertex as the first two dimensions.  The final dimension is for determining the specific cube positions that influence the specified vertex.  The occlusion provides a curve factor but for the purposes of my implementation is linear.  This is meant to control the shading factor brought about by the environment influence (the position of cubes).
    
When determining the light and shading values, we perform a similar lookup to occlusion but we must also factor in the lighting factor for each of the vertices in a given face.  As each of these contribute in a manner to each of the vertices in the face.
    
A cube can be placed at a higher level in the scene to show the effect of shadows on the below cubes.
    
An excellent set of resources for understanding lighting is the blog 0FPS, LetsCode35, and a wrute-up by Florian Bösch.  These references are available in the acknowledgements.
    
See also Appendix G and H to better understand the example cases mentioned above.
    
\section{Implementation}
\subsection{Code and Considerations}
In the code the 3 dimensional list are treated as single dimension arrays.  The index for the single dimension array is computed based on an equation of the form $y * 2w + x*w + z$ as the width and height component are equal.
    
Instead of using a proper \textbf{List3D} implementation that abstracts away these technicalities, I use the existing arrays and a macro for indexing.  
    
\begin{itemize}
	\item Settings of the world are defined in settings.h, but not all values are recorded in the settings.
	      
	\item The flag for toggling UV mapping is helpful for visualizing the lighting and shading of the environment.
	      
	\item Testing and verification was all manual which means there are some strange bugs with respect to ambient occlusion of the code.
\end{itemize}

%-------------------------------------------------------------------------------
% Conclusion
%-------------------------------------------------------------------------------

\chapter{Conclusion}
\section{Initial Iteration}
The initial iteration of \Blockycraft{} had some major flaws in its design due to time constraints and misconceptions that existed during development of the project.  The project was not designed in a way that would enable thorough testing of key algorithms of the project.  Specifically the 3 dimensional data was stored in a \textit{rough} array with poor bounds checking.  This meant under certain conditions it could cause segmentation faults.   

The project did not make use of parallelization, as the original code structure did not lend itself to multi-threaded environments.  The structure of the 3 dimensional list was a key part of ensuring that the code could not easily be parallelized.  As such spatial chunks needed to be generated linearly, which resulted in a significant delay in the application when attempting to regenerate the environment.

The initial iteration was written to be functional, as opposed to expressive.  Improvements in the \Blockycraft{} source code focused on ensuring the code was structured in a testable manner.  By separating the graphics components from the algorithms, this enabled the code to be parallelized and properly validated.

\section{Acknowledgements}
I would like to acknowledge a collection of blog posts by voxel-world enthusiasts who provided the basis of understanding for the project.

\begin{enumerate}
	\item Kenny Voxel Pack. {\em \href{http://kenney.nl/assets/voxel-pack}{Voxel Pack.}} \texttt{(\url{http://kenney.nl/})}
	\item Bösch, F. 2010. {\em \href{http://codeflow.org/entries/2010/dec/09/minecraft-like-rendering-experiments-in-opengl-4/#ambient-occlusion}{Minecraft Like Rendering Experiments in OpenGL 4.}} \texttt{(\url{http://codeflow.org/})}
	\item Let's Code. 2011. {\em \href{http://www.sea-of-memes.com/LetsCode35/LetsCode35.html}{Part 35: Minecraft Lighting.}} \texttt{(\url{http://www.sea-of-memes.com/})}
	\item 0FPS. 2013. {\em \href{https://0fps.net/2013/07/03/ambient-occlusion-for-minecraft-like-worlds/}{Ambient occlusion for Minecraft-like worlds.}} \texttt{(\url{https://0fps.net/})}
	\item Seed of Andromeda. {\em \href{https://www.seedofandromeda.com/blogs/29-fast-flood-fill-lighting-in-a-blocky-voxel-game-pt-1/}{Fast Flood Fill Lighting in a Blocky Voxel Game: Pt 1.}} \texttt{(\url{https://www.seedofandromeda.com})}
	\item ByteBash. 2012. {\em \href{http://bytebash.com/2012/03/opengl-volume-rendering/}{OpenGL Minecraft Style Volume Rendering.}} \texttt{(\url{http://bytebash.com})}
\end{enumerate}

%-------------------------------------------------------------------------------
% References
%-------------------------------------------------------------------------------

\nocite{*}
\begin{thebibliography}{1}
	    
	\bibitem{inoise} Perlin, K. 2002. {\em Improving Noise.} Computer Graphics 35(3).
	\bibitem{gpugems}  Perlin, K. 2004. {\em Implementing Improved Perlin Noise.} GPU Gems
	\bibitem{nparticle}  E. Hastings, R. Guha, and K. O. Stanley,. {\em Neat particles: Design, representation, and animation of particle system effects,} Proceedings of the IEEE Symposium on Computational Intelligence and Games (CIG), 2007
	\bibitem{occl} P. Shanmugam, O. Arikan. {\em Hardware accelerated ambient occlusion techniques on GPUs. }  SIGGRAPH 2007.
	\bibitem{voxel}  Wilder, Michael W., {\em An Investigation in Implementing a C++ Voxel Game Engine with Destructible Terrain } (2015). Honors Research Projects. Paper 217.
	\bibitem{bloxel} E. Arneback, A. Lunden, et al {\em Bloxel - Developing a voxel game engine in Java using OpenGL. } GUPEA 2015.
\end{thebibliography}
\bibliographystyle{plain}
\clearpage

%-------------------------------------------------------------------------------
% Appendix
%-------------------------------------------------------------------------------
\chapter{Appendix}
\appendix

\section{Appendix A - World} \label{AppendixA}
\screenshot{world}{The \Blockycraft{} World.}{ScreenshotA}{1.0\textwidth}
\clearpage

\section{Appendix B - Perlin} \label{AppendixB}
\screenshot{hills}{A generated block world with height corresponding to block type.}{ScreenshotB1}{0.45\textwidth}
\screenshot{plains}{A generated block world with height corresponding to block type.}{ScreenshotB2}{0.45\textwidth}
\screenshot{aerial}{A top-view of a generated block world.}{ScreenshotB3}{0.45\textwidth}
\screenshot{high_frequency}{A generated block world with a high frequency value. ($f=0.8$)}{ScreenshotB4}{0.55\textwidth}
\screenshot{medium_frequency}{A generated block world with a reasonable frequency value. ($f=0.5$)}{ScreenshotB5}{0.55\textwidth}
\screenshot{low_frequency}{A generated block world with a low frequency value. ($f=0.1$)}{ScreenshotB6}{0.55\textwidth}
\clearpage

\section{Appendix C - Transparency Toggle} \label{AppendixC}
\screenshot{transparency}{Transparency toggle on glass blocks.}{ScreenshotC}{1.0\textwidth}
\clearpage


\section{Appendix D - Clouds} \label{AppendixD}
\screenshot{clouds}{Clouds moving in the environment.}{ScreenshotD}{1.0\textwidth}
\clearpage

\section{Appendix E - Particles} \label{AppendixE}
\screenshot{particles}{Particles created after destruction of a block.}{ScreenshotE1}{0.35\textwidth}
\screenshot{particle_angle}{The angle of the particles.}{ScreenshotE2}{0.35\textwidth}
\screenshot{billboard}{The billboarding of the particles.}{ScreenshotE3}{0.35\textwidth}
\clearpage

\section{Appendix F - Light Emitting} \label{AppendixF}
\screenshot{lighting}{Light emitting from a cube.}{ScreenshotF}{1.0\textwidth}
\clearpage

\section{Appendix G - Height Shadows} \label{AppendixG}
\screenshot{shadows}{Ground shadows based on the positioning of cubes.}{ScreenshotG}{0.75\textwidth}
\clearpage

\section{Appendix H - Ambient Occlusion} \label{AppendixH}
\screenshot{aocclusion_angle}{Angled view of ambient occlusion based on nearby block configurations.}{ScreenshotH1}{0.75\textwidth}
\screenshot{aocclusion}{Ambient occlusion based on nearby block configurations.}{ScreenshotH2}{0.75\textwidth}
\end{document}
